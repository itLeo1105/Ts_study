### useEffect 处理副作用的 hook

`js useEffect(()=>{return ()=> {// 可以返回函数，可以在卸载组件时或者是 组件执行完上一次更新时 执行清楚定时器的任务},[]})`

##### 回调函数 第一种不传入第二个参数 组件更新每次都会执行回调；第二种传入一个空数组 只会在渲染时执行一次回调；第三种数组中有依赖项，依赖项改变时回调就会执行

### Usestate

`js const [count,setCount] = useState(0) // 此时不需要指明类型，会有类型推导<br/> const [count,setCount] = useState<Array<{id:number,name:string}>>([]) //如果定义的是一个数组或者对象时需要指定类型`

##### 当遇到 never 类型时，表示类型不能用，不能通过该类型来解析当下的运行模式，必须指明类型

### useRef

##### 当使用 useRef 时必须指明泛型 ---> useRef<HTMLInputElement>(null) 由于 ref.current 属性可能为空可以使用可选链操作符 ? ref.current?.value

### useHistory

##### 1.useHistory 如果没有传参数的时候，可以不用关心类型问题

`js const history = useHistory()<br/> history.push('/login')`

##### 2.传递参数需要规范类型

`js const history = useHistory<{name:string}>() <br/> history.push('/login',{name:'ccc'})`

### useLocation 接收路由 path 携带的参数

`js location.date.xxxx`

##### 1.不接收参数直接使用 const location = useLocation()

##### 2.接收参数使用 const location = useLocation<传入参数的类型 | undefined>() 类型 取值时采用 可选链 or 非空断言 or if()

### useParams 接收动态路由参数

`js const params = useParams({id?:number}) //可设置为可选参数不一定传<br> if(params.id){// do something...}`

### useSelector 使用

##### 第一种方式 指定泛型类型 传入两个泛型的类型

`js useSelector<Rootstate,TodoType>((state)=> state.todos)`

##### 第二种方式不指定泛型 指定 useSelector 回调参数的类型

`js useSelector((state:{todos:TodoList})=> state.todos)`

##### 可以使用 ReturnType 反推出 state 的类型状态

`js const RootState = ReturnType<typeof store.getState()> // store.getState()获取redux 仓库应用状态只需要获取其类型`
